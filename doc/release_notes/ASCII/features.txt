Feature Description

Introduction

These notes document the release of OSF's unencumbered and free
version of the Mach microkernel. This is a kernel-only release; we are
not releasing an unencumbered UNIX server at this time.

This release does not officially include a build environment and
tools, so these notes do not include build and installation
instructions. Note however, that the release does include some
rudimentary (and unencumbered ) build tools. See the top-level README
file for more information.

The release was derived from the OSF MK6.1 release, corresponds to
OSF©s nmk18b4 internal build, and incorporates the results from
several projects at the Open Software Foundation ± Research
Institute. These include the following:

a. The MK6 performance improvement project; this project has
introduced in-kernel mechanisms that allow the microkernel to support
the collocation of OS servers in the kernel's address space.

b. The MK6 device driver asynchronous I/O model which allows task
notification directly from interrupt context.

c. The NMK18 NoRMA project which has contributed enhancements to the
multicomputer support component of the release.

d. The RT2 real-time project which has contributed fundamental
extensions to the kernel in support of real-time applications and
environments.

e. The Microkernel Performance Suite (MKPS).


Support for Collocated Servers

Most of the performance penalties associated with MicroKernel (MK)
systems result from locating an OS server in user space and using a
general-purpose IPC message mechanism to implement RPC, thus adding
overhead to the system call path. As such, the principal strategy for
improving MK performance has been to move the OS server task back into
the kernel address space and to optimize the RPC mechanism for the
case where the client and server share an address space.

Collocation means locating separately-compiled and linked programs in
the same address space. In the current implementation of collocation,
each program runs in a separate task. This corresponds to the original
model of collocating several tasks in the same address space. However,
the model is evolving in the direction of having several separately
compiled and linked programs loaded into a single task.

When programs share the same address space, it becomes possible to
replace IPC message-based RPC with a form of direct procedure call
that is called short-circuited RPC. This is many times more efficient
than message passing, and accounts for the largest single performance
improvement. One of the requirements for this project was to maintain
the modularity of the MK design. In the case of RPC, this means that
collocated programs must not be aware that they are communicating via
short-circuited rather than message-based RPC.

A server must conform to a small set of rules if it is to collocate
itself in the kernel's address space. This release does not include a
collocatable server.

More information can be found in the [5].

Asynchronous Driver Model

In the current MicroKernel (MK), asynchronous I/O completion
notifications are posted to a task using a reply message generated by
the MK. Because messages cannot be sent from interrupt context, an
io_done thread runs in the MK to perform the messaging function. This
io_done thread introduces an additional thread context switch, with
the accompanying performance penalty, on each asynchronous I/O
completion. A new mechanism has been introduced in the MK by which
servers can circumvent the interposition of the io_done thread on each
asynchronous I/O completion.

Instead of waiting on a port set for I/O completion requests, a task
waits on a new kernel object called an io_done_queue. Applications
such as OS servers create a single io_done_queue at server
initialization time. The corresponding wait operation returns the I/O
completion status. For each wait invocation, the status of one I/O
request is returned. If there are no pending I/O completions the wait
operation blocks in the kernel on the address of the completion queue.
The MK, from interrupt context, enqueues (FIFO) completions on the
completion queue and posts a wakeup on it for each I/O completion.
Completion processing previously done by the MK io_done thread is now
done by the task thread when it awakens.


MultiComputer Support

This release updates the NoRMA support in Mach 3.0 to work with the
current kernel source base, and makes NoRMA more scalable by adding MP
safety and efficiency. Thus NoRMA now uses untyped IPC, NoRMA itself
is MP-safe (i.e. has appropriate lock/unlock protocols for use on
multiprocessors), and the underlying XMM implementation has been made
MP-efficient. Much work has gone into increased robustness and into
completing the task of making all kernel VM services work
transparently in the distributed case.


Real-Time Extensions

This release is a continuation of the effort by the OSF-RI in
providing support for real-time applications and environments. The
major areas of real-time functionality provided in MK6.1 are:

·	Synchronizers

OSF MK6.1 supports two new synchronizers: semaphores and locks (see
[1] for more information).

Semaphores are a simple and powerful synchronization primitive that
can be used to implement a host of other synchronization protocols.
The semaphore abstraction is particularly well suited for inter-task
producer/consumer style communication. Tasks may dynamically create
and destroy semaphores as the need arises; additional operations
include signalling, and waiting on, a semaphore. Semaphores are named
by port rights, enabling operations on semaphores to be network
transparent.

Locks are first class entities, which can be created and destroyed, as
well as, locked and unlocked. Lock operations are performed against
lock sets. A lock set represents either a single lock or a collection
of associated locks. Lock sets are named by ports, to allow them to be
referenced across task boundaries; while they are owned by tasks, the
locks are owned by threads. The thread that acquires a lock becomes
the owner of the lock. A lock can only be released by the thread who
owns the lock. Lock ownership may be handed-off between thread.

·	Real-Time threads

This is supplied by a user-level library and is not, therefore,
documented in theKernel API Changes chapter of the Release Notes, see
[3] for a complete description of the library functionality.

·	RPCs for Real-Time

Recent work on existing systems, have indicated that message based
systems that optimize the Remote Procedure Call (RPC) case experience
significant performance improvements. One of the current goals of the
OSF/RI MK project is to realize these improvements in the current
development path for the real-time Mach kernel. This work leverages
the collocation effort and the redefinition of a thread into two
components: a thread and an activation.

Perhaps the most important difference between RT-RPC and Mach IPC
based RPC is the treatment of message meta data. The RPC parameter
data, and the IN and OUT arguments to the remote service, will be
treated separately from the meta data. Every effort will be made to
use the parameter data, without additional copies, as it is provided
by the standard `C' compiler of each target platform. This contrasts
with the mach_msg approach which requires the parameter data to be
coped to the message body. It is possible to send a message or an RPC
to the same port. For a more detailed description of this
functionality, see the included paper [1].

In order to better present the changes to the API, it is important to
briefly define a number of terms:

·	Thread ± Normally an execution stack and processor state.
In Mach, and other systems, a thread is also a schedulable object that
contains scheduling parameters and, possibly scheduling policy
information.

·	Activation ± A Mach thread that is currently associated
with a shuttle.

·	Unbound Activation ± An activation that is not currently
associated with a shuttle.

·	Shuttle ± This contains the scheduling policy and
parameters, as well as cpu usage and a pointer to the current thread.
The shuttle is the part of the thread/shuttle system that can migrate,
while the thread part remains with the task in which it was created.

·	RPC chain ± Active threads (i.e. activations) in different
tasks linked by RPC calls.

·	Alert ± A software generated exception that affects the
thread at which the shuttle is currently pointing.

·	Signature ± An array of descriptors that describe the
kernel visible arguments (e.g. ports) pushed on the stack for an RPC
call.

·	Subsystem ± A data structure registered by an RPC target
task to allow the kernel to marshall and unmarshall arguments and
directly invoke task work functions.

Microkernel Performance Suite

The Microkernel Performance Suite (MKPS) is a framework to take
multiple measurements of each microkernel system service and compute
the average performance and its standard deviation. It calibrates the
number of iterations to get a significant measure (it has to perform
enough iterations to get a low variation in the measure, but not too
many to make sure that the results are available after a reasonable
time), and automatically invokes the tests selected by the user. It
also provides some tools to detect resources leak that might affect
the results. The set of microkernel services measured involve IPC, VM,
exception handling, scheduling, port, task and thread manipulation,
EMMI, and device services. Since there are no Kernel API modifications
for this feature, see [1] for a complete description.

Reference Papers

[1]	Barbou des Places, FranÛois, Philippe Bernadat ,ªOSF
Microkernel Benchmark Suiteº, OSF Research Institute, Cambridge,
MA, July, 1994.

[2]	Burke, Edward, Michael Condict, David Mitchell, Franklin
Reynolds, Peter Watkins, William Willcox, ªRPC Design for Real-Time
Machº, OSF Research Institute, Cambridge, MA, April, 1994.

[3]	CaraDonna, Joseph, ªOSF±RI MK6.1 Real-Time Threads
Library: Rthreads Interface Guideº, OSF Research Institute,
Cambridge, MA, DRAFT: September 8, 1994.

[4]	CaraDonna, Joseph, Robert Haydt, Franklin Reynolds, ªNew
Synchronization Services for OSF Mach: Synchronizersº, OSF Research
Institute, Cambridge, MA, April 12, 1994.

[5]	Condict, Michael, Don Bolinger, Eamonn McManus, David
Mitchell, Steve Lewontin, ªMicrokernel Modularity With Integrated
Kernel Performanceº, OSF Research Institute, Cambridge, MA, April,
1994.

[6]	Haydt, Robert, Joseph CaraDonna, Franklin Reynolds, ªMach
Scheduling Frameworkº, OSF Research Institute, Cambridge, MA,
April, 1994.

[7]	Langerman, Alan, David Black, Michelle Dominijanni, Steve
Sears, Randall Dean, Dejan Milojicic, ªNORMA IPC Version Two:
Architecture and Designº, OSF Research Institute, Cambridge, MA,
April, 1994.

